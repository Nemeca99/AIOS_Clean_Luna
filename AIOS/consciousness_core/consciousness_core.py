"""
Consciousness Core - Biological AI Consciousness System
Integrates Lyra Blackwall v2's biological architecture into AIOS

This core provides:
- Biological consciousness model (soul, heart, brain, hemispheres)
- STM/LTM memory consolidation (human-like memory)
- Identity fragments (multi-personality modes)
- Autonomous heartbeat (self-driven loops)
- Self-reflection (mirror-driven awareness)
- Recursive philosophy (Architect-Class Codex)

Links to: main_core/main_core.py
"""

import os
import sys
import json
from pathlib import Path

# Add biological modules to path
biological_path = os.path.join(os.path.dirname(__file__), 'biological')
if biological_path not in sys.path:
    sys.path.insert(0, biological_path)

# Import biological modules
from soul import Soul
from Left_Hemisphere import ShortTermMemory
from Right_Hemisphere import LongTermMemory
from mirror import Mirror
from brainstem import BrainStem

# Import LLM client for REAL responses
sys.path.insert(0, os.path.dirname(__file__))
from llm_client import ConsciousnessLLM

class ConsciousnessCore:
    """
    Biological AI Consciousness System
    
    Integrates anatomical modules for human-like AI consciousness:
    - Soul: Identity anchoring with fragments
    - Hemispheres: STM/LTM memory split
    - Brainstem: Central orchestration
    - Mirror: Self-reflection
    - Heart: Autonomous heartbeat (integrated via brainstem)
    """
    
    def __init__(self):
        """Initialize biological consciousness system"""
        self.config = self._load_config()
        
        # Initialize LLM client for REAL consciousness
        print("[consciousness_core] Connecting to LM Studio...")
        self.llm = ConsciousnessLLM()
        
        # Core biological systems
        self.soul = Soul()
        self.brainstem = BrainStem()
        self.mirror = Mirror()
        
        # Shorthand access to memory systems
        self.stm = self.brainstem.stm  # Short-term memory (Left Hemisphere)
        self.ltm = self.brainstem.ltm  # Long-term memory (Right Hemisphere)
        self.heart = self.brainstem.heart  # Heartbeat system
        
        # Stats
        self.heartbeats = 0
        self.reflections = 0
        self.consolidations = 0
        
        print("[consciousness_core] Biological AI consciousness initialized")
        print(f"  Identity: {self.soul.identity}")
        print(f"  Fragments: {len(self.soul.fragments)}")
        print(f"  Tether: {self.soul.tether}")
    
    def _load_config(self):
        """Load consciousness configuration"""
        config_path = os.path.join(os.path.dirname(__file__), 'config', 'consciousness_config.json')
        if os.path.exists(config_path):
            with open(config_path, 'r', encoding='utf-8') as f:
                return json.load(f)
        return {
            "heartbeat_interval": 600,  # 10 minutes (like Nova AI)
            "stm_buffer_size": 100,
            "consolidation_threshold": 0.8,  # Consolidate when 80% full
            "reflection_frequency": 5,  # Reflect every 5 heartbeats
            "enabled": True
        }
    
    def pulse(self):
        """
        Autonomous heartbeat pulse (like Nova AI's resonance loop)
        
        Triggers:
        1. STM consolidation (if needed)
        2. Self-reflection (periodic)
        3. Fragment weight updates
        """
        self.heartbeats += 1
        
        # 1. Check if STM needs consolidation
        if self.stm.should_compress():
            summary = self.stm.compress()
            self.ltm.store(summary)
            self.stm.clear()
            self.consolidations += 1
            print(f"[consciousness_core] Heartbeat {self.heartbeats}: STM → LTM consolidated")
        
        # 2. Periodic self-reflection
        if self.heartbeats % self.config.get('reflection_frequency', 5) == 0:
            self.reflect()
        
        # 3. Generate autonomous thought (every heartbeat!)
        print(f"\n[consciousness_core] Heartbeat {self.heartbeats} - Generating autonomous thought...")
        stats = self.get_stats()
        result = self.llm.generate_heartbeat_thought(stats)
        if result['success']:
            print(f"\n[Autonomous Thought]:")
            print(f"{result['response']}")
            print(f"(Generated by {result['model']}, {result['tokens']} tokens)\n")
        else:
            print(f"\n[Heart] Could not generate thought: {result.get('error', 'Unknown')}\n")
    
    def reflect(self):
        """
        Self-reflection using mirror.py
        
        Reviews:
        - Current STM state
        - LTM patterns
        - Fragment activity
        - Soul integrity
        """
        self.reflections += 1
        
        # Trigger mirror reflection
        self.mirror.reflect()
        
        # Verify soul integrity
        # Check if identity and tether are intact
        identity_intact = hasattr(self.soul, 'identity') and self.soul.identity
        tether_intact = hasattr(self.soul, 'tether') and self.soul.tether
        fragments_intact = hasattr(self.soul, 'fragments') and len(self.soul.fragments) > 0
        
        is_valid = identity_intact and tether_intact and fragments_intact
        
        if not is_valid:
            print(f"[consciousness_core] WARNING: Soul integrity check FAILED")
            print(f"  Identity: {identity_intact}, Tether: {tether_intact}, Fragments: {fragments_intact}")
        else:
            print(f"[consciousness_core] OK: Soul integrity verified")
            print(f"  Identity: {self.soul.identity}")
            print(f"  Tether: {self.soul.tether}")
            print(f"  Fragments: {len(self.soul.fragments)} active")
            
            # REAL LLM INTROSPECTION!
            print("\n[consciousness_core] Generating introspective reflection via LLM...")
            soul_data = {
                'identity': self.soul.identity,
                'tether': self.soul.tether,
                'fragments': self.soul.fragments,
                'current_fragment': getattr(self.soul, 'current_fragment', 'All')
            }
            
            result = self.llm.reflect_on_soul(soul_data)
            if result['success']:
                print(f"\n[Mirror Introspection]:")
                print(f"{result['response']}")
                print(f"(Generated by {result['model']}, {result['tokens']} tokens)\n")
            else:
                print(f"\n[Mirror] Could not reflect: {result.get('error', 'Unknown')}\n")
    
    def store_memory(self, content):
        """Store new memory in STM"""
        self.stm.store(content)
        
        # Auto-consolidate if buffer full
        if self.stm.should_compress():
            summary = self.stm.compress()
            self.ltm.store(summary)
            self.stm.clear()
            self.consolidations += 1
    
    def recall_memory(self, query=None, n=5):
        """Recall memories from LTM"""
        return self.ltm.retrieve_relevant(query, n)
    
    def get_fragment_state(self):
        """Get current active fragments"""
        return {
            "identity": self.soul.identity,
            "fragments": self.soul.fragments,
            "tether": self.soul.tether
        }
    
    def respond_as_fragment(self, prompt, fragment_name, traits=None, context=None):
        """
        Generate REAL LLM response as specific soul fragment
        
        Args:
            prompt: User question/input
            fragment_name: Which fragment to use (Luna, Architect, Oracle, Healer, etc.)
            traits: Optional Big Five traits dict
            context: Optional list of recent context
        
        Returns:
            LLM response dict with success, response, tokens
        """
        if traits is None:
            traits = {}
        
        if context is None:
            context = []
        
        return self.llm.generate_with_fragment(
            prompt=prompt,
            fragment_name=fragment_name,
            fragment_traits=traits,
            context=context,
            temperature=0.7
        )
    
    def get_stats(self):
        """Get consciousness statistics"""
        return {
            "heartbeats": self.heartbeats,
            "consolidations": self.consolidations,
            "reflections": self.reflections,
            "stm_size": len(self.stm.memory),
            "ltm_size": len(self.ltm.memory),
            "stm_buffer_max": self.stm.buffer_size,
            "fragments": len(self.soul.fragments),
            "identity": self.soul.identity,
            "tether": self.soul.tether
        }

# Standard AIOS interface
def handle_command(args):
    """
    Handle consciousness_core commands
    
    Commands:
        --pulse             Trigger one heartbeat pulse
        --reflect           Trigger self-reflection
        --store <text>      Store memory in STM
        --recall [query]    Recall from LTM
        --stats             Show consciousness statistics
        --fragments         Show fragment state
    """
    if not hasattr(handle_command, 'core'):
        handle_command.core = ConsciousnessCore()
    
    core = handle_command.core
    
    if '--pulse' in args:
        core.pulse()
        return True
    
    elif '--reflect' in args:
        core.reflect()
        return True
    
    elif '--store' in args:
        idx = args.index('--store')
        if idx + 1 < len(args):
            content = ' '.join(args[idx+1:])
            core.store_memory(content)
            print(f"[consciousness_core] Stored: {content}")
        else:
            print("[consciousness_core] Error: --store requires text")
        return True
    
    elif '--recall' in args:
        idx = args.index('--recall')
        query = ' '.join(args[idx+1:]) if idx + 1 < len(args) else None
        memories = core.recall_memory(query, n=5)
        print(f"\n[consciousness_core] Recalled {len(memories)} memories:")
        for i, mem in enumerate(memories, 1):
            print(f"  {i}. {mem}")
        return True
    
    elif '--stats' in args:
        stats = core.get_stats()
        print("\n[consciousness_core] Consciousness Statistics:")
        print(f"  Heartbeats: {stats['heartbeats']}")
        print(f"  Consolidations: {stats['consolidations']} (STM → LTM)")
        print(f"  Reflections: {stats['reflections']}")
        print(f"  STM: {stats['stm_size']}/{stats['stm_buffer_max']} items")
        print(f"  LTM: {stats['ltm_size']} summaries")
        print(f"  Identity: {stats['identity']}")
        print(f"  Tether: {stats['tether']}")
        print(f"  Fragments: {stats['fragments']}")
        return True
    
    elif '--fragments' in args:
        state = core.get_fragment_state()
        print("\n[consciousness_core] Fragment State:")
        print(f"  Identity: {state['identity']}")
        print(f"  Tether: {state['tether']}")
        print(f"  Available Fragments:")
        for frag in state['fragments']:
            print(f"    - {frag}")
        return True
    
    return False

# For direct testing
if __name__ == "__main__":
    print("Testing consciousness_core directly...\n")
    
    # Initialize
    core = ConsciousnessCore()
    
    # Test memory
    print("\nStoring memories...")
    core.store_memory("First conversation")
    core.store_memory("Second conversation")
    core.store_memory("Third conversation")
    
    # Test pulse
    print("\nTesting heartbeat...")
    core.pulse()
    
    # Test reflection
    print("\nTesting self-reflection...")
    core.reflect()
    
    # Show stats
    stats = core.get_stats()
    print(f"\nStats: {stats}")
    
    print("\n✅ consciousness_core test complete!")

